# firmware/src/processorSpecific/ST/STM32F10/Sconscript

from __future__ import absolute_import
import json
from tools.buildTools import processFeature

# TODO: Be smarter about the paths and the backtracking.
# TODO: Consider tracking pads to ensure the same pad isn't defined for two things. Could also be done in a dedicated json checker before this step

def pinConfig(projectDir, verbose):

    pinConfigName = "../../../" + projectDir + '/pinConfig.json'
    print(f"Loading pin config from {projectDir + '/pinConfig.json'}")
    pinConfig = json.loads(File(pinConfigName).get_text_contents())

    if 'GPIO' in pinConfig:
        if verbose:
            print("  Generating GPIO files")
        generateGPIOHFile(projectDir, pinConfig['GPIO'])
        generateGPIOCFile(projectDir, pinConfig['GPIO'])


def generateGPIOHFile(projectDir, gpioData):
    with open("../../../" + projectDir + "/generated/HW/HW_GPIO_generated.h", "w") as gpioFile:
        gpioFile.write("// This file is generated by src/processorSpecific/ST/STM32F10/Sconscript\n")
        gpioFile.write(f"// The data to populate this file is loaded from {projectDir}/pinConfig.json\n\n")

        gpioFile.write("#ifndef __HW_GPIO_GENERATED_H__\n")
        gpioFile.write("#define __HW_GPIO_GENERATED_H__\n\n")

        gpioFile.write("#include \"stm32f10x_gpio.h\"\n\n")

        gpioFile.write("typedef enum\n")
        gpioFile.write("{\n")
        for gpio in gpioData:
            gpioFile.write(f"    HW_GPIO_{gpioData[gpio]['Name']},\n")
        gpioFile.write("    HW_GPIO_COUNT\n")
        gpioFile.write("} HW_GPIO_Pin;\n\n")

        gpioFile.write("#endif // __HW_GPIO_GENERATED_H__\n")
        gpioFile.close()


def generateGPIOCFile(projectDir, gpioData):
    with open("../../../" + projectDir + "/generated/HW/HW_GPIO_generated.c", "w") as gpioFile:
        gpioFile.write("// This file is generated by src/processorSpecific/ST/STM32F10/Sconscript\n")
        gpioFile.write(f"// The data to populate this file is loaded from {projectDir}/pinConfig.json\n\n")

        gpioFile.write("#include \"HW_GPIO_generated.h\"\n\n")

        gpioFile.write("struct HW_GPIO_generatedData\n")
        gpioFile.write("{\n")
        gpioFile.write("    GPIO_InitTypeDef pinData[HW_GPIO_COUNT];\n")
        gpioFile.write("    GPIO_TypeDef* port[HW_GPIO_COUNT];\n")
        gpioFile.write("    BitAction defaultState[HW_GPIO_COUNT];\n")
        gpioFile.write("};\n\n")

        gpioFile.write("static struct HW_GPIO_generatedData gpioData;\n\n")

        gpioFile.write("void HW_GPIO_Init(void)\n")
        gpioFile.write("{\n")
        for gpio in gpioData:
            # Split the gpio into the port and pin
            port = gpio[1]
            pin = gpio[2]

            gpioFile.write(f"    gpioData.port[HW_GPIO_{gpioData[gpio]['Name']}] = GPIO{port};\n")
            gpioFile.write(f"    gpioData.pinData[HW_GPIO_{gpioData[gpio]['Name']}] = (GPIO_InitTypeDef){{\n")
            gpioFile.write(f"        .GPIO_Pin = GPIO_Pin_{pin},\n")
            gpioFile.write(f"        .GPIO_Mode = GPIO_Mode_{gpioData[gpio]['Mode']},\n")
            gpioFile.write(f"        .GPIO_Speed = GPIO_Speed_{gpioData[gpio]['Speed']},\n")
            gpioFile.write(f"    }};\n")
            gpioFile.write(f"    gpioData.defaultState[HW_GPIO_{gpioData[gpio]['Name']}] = Bit_{gpioData[gpio]['DefaultState']};\n")

            gpioFile.write(f"    GPIO_Init(gpioData.port[HW_GPIO_{gpioData[gpio]['Name']}], &gpioData.pinData[HW_GPIO_{gpioData[gpio]['Name']}]);\n")
            gpioFile.write(f"    GPIO_WriteBit(gpioData.port[HW_GPIO_{gpioData[gpio]['Name']}], gpioData.pinData[HW_GPIO_{gpioData[gpio]['Name']}].GPIO_Pin, gpioData.defaultState[HW_GPIO_{gpioData[gpio]['Name']}]);\n\n")
        gpioFile.write("}\n\n")

        gpioFile.close()

def setupEnvForArm(env):
    # From: https://elektronotes.wordpress.com/2015/02/05/using-scons-with-gnu-toolchain-for-arm-on-windows-part-3-the-scons-script/
    env['AR'] = 'arm-none-eabi-ar'
    env['AS'] = 'arm-none-eabi-as'
    env['CC'] = 'arm-none-eabi-gcc'
    env['CXX'] = 'arm-none-eabi-g++'
    env['LINK'] = 'arm-none-eabi-g++'                # predefined is 'arm-none-eabi-gcc'
    env['RANLIB'] = 'arm-none-eabi-ranlib'
    env['OBJCOPY'] = 'arm-none-eabi-objcopy'
    env['PROGSUFFIX'] = '.elf'

    # compiler flags
    env.Append(CCFLAGS = [
    '-mcpu=cortex-m3',
    '-mthumb',
    '-O2',
    '-fsigned-char',
    '-ffunction-sections',
    '-fdata-sections',
    '-std=gnu11',
    '-fmessage-length=0',
    '-mthumb-interwork',
    ])

# linker flags
    env.Append(LINKFLAGS = [
    '-ffunction-sections',
    '-fdata-sections',
    '-Tsrc/processorSpecific/ST/STM32F10/manufacturer/stm32f10x_flash_ROArray.ld',
    '-Xlinker',
    '--gc-sections'
    # '--specs=nano.specs',
    ])


Import('projectDir', 'env', 'featuresEnabled', 'verbose')

setupEnvForArm(env)

processorFeatureList = json.loads(File('featureList.json').get_text_contents())
sources = []
newFeatures = []
for feature in featuresEnabled:
    featuresEnabled, newSources = processFeature(feature, featuresEnabled, processorFeatureList, verbose)
    sources.extend(newSources)

print("Generating pin config")
pinConfig(projectDir, verbose)

env.Append(CPPPATH = ['processorSpecific\ST\STM32F10\manufacturer'])

Return('featuresEnabled', 'sources')
