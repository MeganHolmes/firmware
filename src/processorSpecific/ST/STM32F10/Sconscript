# firmware/src/processorSpecific/ST/STM32F10/Sconscript

from __future__ import absolute_import
import json
from src.tools.buildTools import processFeature

# TODO: https://github.com/MeganHolmes/firmware/issues/14 Be smarter about the paths and the backtracking.
# TODO: https://github.com/MeganHolmes/firmware/issues/13 Consider tracking pads to ensure the same pad isn't defined for two things. Could also be done in a dedicated json checker before this step

# def pinConfig(projectDir, verbose):

#     pinConfigName = "../../../" + projectDir + '/pinConfig.json'
#     print(f"Loading pin config from {projectDir + '/pinConfig.json'}")
#     pinConfig = json.loads(File(pinConfigName).get_text_contents())

#     if 'GPIO' in pinConfig:
#         if verbose:
#             print("  Generating GPIO file")
#         generateGPIOHFile(projectDir, pinConfig['GPIO'])

# TODO: https://github.com/MeganHolmes/firmware/issues/21 Switch to a better template system.
# def generateGPIOHFile(projectDir, gpioData):
#     with open("../../../../build/" + projectDir + "/generated/HW/HW_GPIO_generated.h", "w") as gpioFile:
#         gpioFile.write("// This file is generated by src/processorSpecific/ST/STM32F10/Sconscript\n")
#         gpioFile.write(f"// The data to populate this file is loaded from {projectDir}/pinConfig.json\n\n")

#         gpioFile.write("#ifndef __HW_GPIO_GENERATED_H__\n")
#         gpioFile.write("#define __HW_GPIO_GENERATED_H__\n\n")

#         gpioFile.write("#include \"stm32f10x_gpio.h\"\n")
#         gpioFile.write("#include \"HW_GPIO.h\"\n\n")

#         gpioFile.write("typedef enum\n")
#         gpioFile.write("{\n")
#         for gpio in gpioData:
#             gpioFile.write(f"    HW_GPIO_{gpioData[gpio]['Name']},\n")
#         gpioFile.write("    HW_GPIO_COUNT\n")
#         gpioFile.write("} HW_GPIO_Pin;\n\n")

#         gpioFile.write("static const HW_GPIO_Data HW_GPIO_generated_config[HW_GPIO_COUNT] =\n")
#         gpioFile.write("{\n")
#         for gpio in gpioData:
#             # Split the gpio into the port and pin
#             port = gpio[1]
#             pin = gpio[2]
#             gpioFile.write(f"    [HW_GPIO_{gpioData[gpio]['Name']}] =\n")
#             gpioFile.write("    {\n")
#             gpioFile.write(f"        .port = GPIO{port}\n")
#             gpioFile.write(f"        ->pinData = (GPIO_InitTypeDef){{\n")
#             gpioFile.write(f"            .GPIO_Pin = GPIO_Pin_{pin},\n")
#             gpioFile.write(f"            .GPIO_Mode = GPIO_Mode_{gpioData[gpio]['Mode']},\n")
#             gpioFile.write(f"            .GPIO_Speed = GPIO_Speed_{gpioData[gpio]['Speed']},\n")
#             gpioFile.write("        }\n")
#             gpioFile.write(f"        .defaultState = Bit_{gpioData[gpio]['DefaultState']}\n")
#             gpioFile.write("    },\n")
#         gpioFile.write("};\n\n")


#         gpioFile.write("#endif // __HW_GPIO_GENERATED_H__\n")
#         gpioFile.close()

def setupEnvForArm(env):
    # Orignally From: https://elektronotes.wordpress.com/2015/02/05/using-scons-with-gnu-toolchain-for-arm-on-windows-part-3-the-scons-script/
    # Comments after each line added by me to ensure full understanding of what is happening.
    # I also disabled options that I don't know what they do or don't seem to be needed. In general fewer options is better.
    env['AR'] = 'arm-none-eabi-ar'
    env['AS'] = 'arm-none-eabi-as'
    env['CC'] = 'arm-none-eabi-gcc'
    env['CXX'] = 'arm-none-eabi-g++'
    env['LINK'] = 'arm-none-eabi-ld'
    env['RANLIB'] = 'arm-none-eabi-ranlib'
    env['OBJCOPY'] = 'arm-none-eabi-objcopy'
    env['PROGSUFFIX'] = '.elf'

    # Optimization Notes. Below are options that I might use.
    # -O0 = Reduce compilation time and make debugging produce the expected results. Use for fast compiles.
    # -03 = the compiler tries to reduce code size and execution time. Still maintains standards compliance unlike -Ofast. Use for production unless size is a concern.
    # -Og = Optimize debugging experience. Use for use with debuggers.
    # -Oz = Optimize for size. Similar to -Os but more aggressive. Use for size constrained environments.
    # Full list: https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html

    # compiler flags
    env.Append(CCFLAGS = [
    '-mcpu=cortex-m3', # Specify the CPU to compile for.
    '-mthumb', # Something to do with different instruction sets.
    '-Og',
    # '-fsigned-char', #  Let the type char be signed, like signed char. Don't know why I would need this right now.
    # '-ffunction-sections', #  Place each function or data item into its own section in the output file if the target supports arbitrary sections. Tries to reduce file size but that's not an issue right now
    # '-fdata-sections', # Same as above but for data.
    '-std=gnu17', # Determine the language standard. Using newest GNU version until C23 is released. Mostly so I can use 0b binary literals.
    # '-fmessage-length=0', # formats error messages to fit on lines of n characters. I don't care about this right now.
    # '-mthumb-interwork', # Something to do with different instruction sets
    '-march=armv7-m',
    '--save-temps', # Save intermediate files for debugging.
    '-fverbose-asm', # Add extra comments to the assembly code. Useful for debugging.
    '-Wall', # Enable all warnings. Useful for debugging.
    '-Wextra', # Enable extra warnings. Useful for debugging.
    # '-Werror', # Treat warnings as errors. Useful for debugging. # TODO: Enable this after https://github.com/MeganHolmes/firmware/issues/15 is fixed
    '-g3', # Produce debugging information. Useful for debugging.
    # '-nostdlib',
    # '-standalone',
    # '-nostdinc',
    ])

    # linker flags
    env.Append(LINKFLAGS = [
    # '-ffunction-sections', # See above explanations
    # '-fdata-sections',
    '-Tsrc/processorSpecific/ST/STM32F10/manufacturer/stm32_flash.ld', # Specify the linker script.
    # '-Xlinker', # Pass the following argument to the linker.
    # '--gc-sections',
    # '--specs=nosys.specs', # Fixes the _exit linking issue. Something to do with compiling for ARM on x86.
    # '--specs=nano.specs',
    '-g', # Perserve debugging information from the compile step so it can be used by a debugger.
    ])


Import('projectDir', 'env', 'featuresEnabled', 'verbose')

setupEnvForArm(env)

processorFeatureList = json.loads(File('featureList.json').get_text_contents())
sources = []
newFeatures = []
for feature in featuresEnabled:
    featuresEnabled, newSources = processFeature(feature, featuresEnabled, sources, processorFeatureList, verbose)

# print("Generating pin config")
# pinConfig(projectDir, verbose)

env.Append(CPPPATH = ['processorSpecific/ST/STM32F10/manufacturer',
                      'processorSpecific/ST/STM32F10/HW'])

Return('featuresEnabled', 'sources')
